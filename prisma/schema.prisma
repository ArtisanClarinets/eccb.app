generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
}

// ====================================
// Users & Authentication
// ====================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified Boolean   @default(false)
  name          String?
  image         String?
  
  password      String?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  deletedAt     DateTime?
  
  twoFactorEnabled Boolean @default(false)
  role             String?
  banned           Boolean @default(false)
  banReason        String?
  banExpires       DateTime?
  
  accounts      Account[]
  sessions      Session[]
  roles         UserRole[]
  member        Member?
  
  auditLogs     AuditLog[]
  notifications UserNotification[]
  emailLogs     EmailLog[]
  announcements Announcement[]
  customPermissions UserPermission[]
  
  @@index([email])
  @@index([deletedAt])
}

model Account {
  id                    String    @id @default(cuid())
  userId                String
  accountId             String
  providerId            String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("account")
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("session")
}

model Verification {
  id         String   @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@map("verification")
}

// ====================================
// Roles & Permissions
// ====================================

enum RoleType {
  SUPER_ADMIN
  ADMIN
  DIRECTOR
  STAFF
  SECTION_LEADER
  LIBRARIAN
  MUSICIAN
  PUBLIC
}

model Role {
  id          String   @id @default(cuid())
  name        String   @unique
  displayName String
  description String?
  type        RoleType
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  users       UserRole[]
  permissions RolePermission[]
  
  @@index([type])
}

model UserRole {
  id        String   @id @default(cuid())
  userId    String
  roleId    String
  
  assignedAt DateTime @default(now())
  assignedBy String?
  expiresAt  DateTime?
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@unique([userId, roleId])
  @@index([userId])
  @@index([roleId])
}

model Permission {
  id          String   @id @default(cuid())
  name        String   @unique
  resource    String
  action      String
  scope       String?
  description String?
  
  createdAt   DateTime @default(now())
  
  roles       RolePermission[]
  userPermissions UserPermission[]
  
  @@index([resource, action])
}

model RolePermission {
  id           String @id @default(cuid())
  roleId       String
  permissionId String
  
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

model UserPermission {
  id           String   @id @default(cuid())
  userId       String
  permissionId String
  grantedAt    DateTime @default(now())
  grantedBy    String?
  expiresAt    DateTime?
  
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@unique([userId, permissionId])
  @@index([userId])
  @@index([permissionId])
}

// ====================================
// Members & Profiles
// ====================================

enum MemberStatus {
  ACTIVE
  INACTIVE
  LEAVE_OF_ABSENCE
  ALUMNI
  AUDITION
  PENDING
}

model Member {
  isSubstitute Boolean @default(false)
  sectionMessages SectionMessage[]
  carpoolEntries CarpoolEntry[]

  id              String       @id @default(cuid())
  userId          String?      @unique
  firstName       String
  lastName        String
  email           String?
  phone           String?
  profilePhoto    String?
  status          MemberStatus @default(PENDING)
  joinDate        DateTime?
  leaveDate       DateTime?
  emergencyName   String?
  emergencyPhone  String?
  emergencyEmail  String?
  notes           String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  deletedAt       DateTime?
  
  user            User?        @relation(fields: [userId], references: [id])
  instruments     MemberInstrument[]
  sections        MemberSection[]
  attendance      Attendance[]
  musicAssignments MusicAssignment[]
  
  @@index([status])
  @@index([lastName, firstName])
  @@index([deletedAt])
}

model Instrument {
  id          String   @id @default(cuid())
  name        String   @unique
  family      String
  sortOrder   Int      @default(0)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  members     MemberInstrument[]
  musicParts  MusicPart[]
  
  @@index([family])
  @@index([sortOrder])
}

model MemberInstrument {
  id           String   @id @default(cuid())
  memberId     String
  instrumentId String
  isPrimary    Boolean  @default(false)
  
  member     Member     @relation(fields: [memberId], references: [id], onDelete: Cascade)
  instrument Instrument @relation(fields: [instrumentId], references: [id])
  
  @@unique([memberId, instrumentId])
  @@index([memberId])
  @@index([instrumentId])
}

model Section {
  messages SectionMessage[]

  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  sortOrder   Int      @default(0)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  members     MemberSection[]
  
  @@index([sortOrder])
}

model MemberSection {
  id        String   @id @default(cuid())
  memberId  String
  sectionId String
  isLeader  Boolean  @default(false)
  
  assignedAt DateTime @default(now())
  
  member  Member  @relation(fields: [memberId], references: [id], onDelete: Cascade)
  section Section @relation(fields: [sectionId], references: [id])
  
  @@unique([memberId, sectionId])
  @@index([memberId])
  @@index([sectionId])
}

// ====================================
// Music Library (Core)
// ====================================

enum MusicDifficulty {
  GRADE_1
  GRADE_2
  GRADE_3
  GRADE_4
  GRADE_5
  GRADE_6
}

model MusicPiece {
  id              String           @id @default(cuid())
  title           String
  subtitle        String?
  composerId      String?
  arrangerId      String?
  publisherId     String?
  difficulty      MusicDifficulty?
  duration        Int?
  genre           String?
  style           String?
  instrumentation String?
  tags            Json?
  catalogNumber   String?          @unique
  notes           String?
  performanceHistory String?
  isArchived      Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  deletedAt       DateTime?
  
  composer        Person?          @relation("ComposerPieces", fields: [composerId], references: [id])
  arranger        Person?          @relation("ArrangerPieces", fields: [arrangerId], references: [id])
  publisher       Publisher?       @relation(fields: [publisherId], references: [id])
  files           MusicFile[]
  parts           MusicPart[]
  assignments     MusicAssignment[]
  eventMusic      EventMusic[]
  
  @@index([title])
  @@index([composerId])
  @@index([difficulty])
  @@index([isArchived])
  @@index([deletedAt])
}

enum FileType {
  FULL_SCORE
  CONDUCTOR_SCORE
  PART
  CONDENSED_SCORE
  AUDIO
  LICENSING
  OTHER
}

// ====================================
// Smart Upload Enums
// ====================================

enum SmartUploadStatus {
  CREATED
  UPLOADING
  PROCESSING
  NEEDS_REVIEW
  APPROVED
  INGESTING
  COMPLETE
  FAILED
  CANCELLED
}

enum SmartUploadStep {
  VALIDATED
  TEXT_EXTRACTED
  METADATA_EXTRACTED
  SPLIT_PLANNED
  SPLIT_COMPLETE
  INGESTED
}

// Upload Pipeline Task Types for model assignment
enum UploadTaskType {
  METADATA_EXTRACTION
  AUDIO_ANALYSIS
  SUMMARIZATION
  TRANSCRIPTION
  CLASSIFICATION
}

model MusicFile {
  id                String   @id @default(cuid())
  pieceId           String
  fileName          String
  fileType          FileType
  fileSize          Int
  mimeType          String
  storageKey        String
  storageUrl        String?
  version           Int      @default(1)
  description       String?
  isPublic          Boolean  @default(false)
  isArchived        Boolean  @default(false)
  uploadedAt        DateTime @default(now())
  uploadedBy        String?

  // Smart Upload extended fields
  contentHash          String?   // For deduplication
  extractedMetadata    Json?     // LLM-extracted metadata
  ocrText              String?   @db.Text // OCR-extracted text
  source               String?
  originalUploadId     String?   // Link to SmartUploadItem if uploaded via smart upload

  piece       MusicPiece @relation(fields: [pieceId], references: [id], onDelete: Cascade)
  parts       MusicPart[]
  downloads   FileDownload[]
  versions    MusicFileVersion[]

  @@index([pieceId])
  @@index([fileType])
}

model MusicFileVersion {
  id            String   @id @default(cuid())
  fileId        String
  version       Int
  fileName      String
  storageKey    String
  fileSize      Int
  mimeType      String
  changeNote    String?
  uploadedAt    DateTime @default(now())
  uploadedBy    String?
  
  file          MusicFile @relation(fields: [fileId], references: [id], onDelete: Cascade)
  
  @@unique([fileId, version])
  @@index([fileId])
  @@index([uploadedAt])
}

model MusicPart {
  id          String  @id @default(cuid())
  pieceId     String
  instrumentId String
  partName     String
  fileId      String?
  isOptional  Boolean @default(false)
  notes       String?
  
  piece        MusicPiece  @relation(fields: [pieceId], references: [id], onDelete: Cascade)
  instrument   Instrument  @relation(fields: [instrumentId], references: [id])
  file         MusicFile? @relation(fields: [fileId], references: [id])
  
  @@index([pieceId])
  @@index([instrumentId])
}

model Person {
  id              String       @id @default(cuid())
  firstName       String
  lastName        String
  fullName        String
  bio             String?
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  
  composedPieces  MusicPiece[] @relation("ComposerPieces")
  arrangedPieces  MusicPiece[] @relation("ArrangerPieces")
  
  @@index([lastName, firstName])
}

model Publisher {
  id          String       @id @default(cuid())
  name        String       @unique
  website     String?
  contactInfo String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  
  pieces      MusicPiece[]
  
  @@index([name])
}

model MusicAssignment {
  id           String           @id @default(cuid())
  pieceId      String
  memberId     String
  partName     String?
  partId       String?          // Link to specific MusicPart
  copyNumber   Int?             // For tracking multiple copies of same part
  priority     Int?
  notes        String?
  status       AssignmentStatus @default(ASSIGNED)
  assignedAt   DateTime         @default(now())
  assignedBy   String?
  pickedUpAt   DateTime?
  pickedUpBy   String?
  dueDate      DateTime?
  returnedAt   DateTime?
  returnedTo   String?
  condition    String?          // Condition notes when returned
  missingSince DateTime?        // When the part was reported missing
  missingNotes String?          // Notes about missing/lost parts
  
  piece        MusicPiece       @relation(fields: [pieceId], references: [id], onDelete: Cascade)
  member       Member           @relation(fields: [memberId], references: [id], onDelete: Cascade)
  history      MusicAssignmentHistory[]
  
  @@index([pieceId])
  @@index([memberId])
  @@index([dueDate])
  @@index([status])
}

model MusicAssignmentHistory {
  id           String   @id @default(cuid())
  assignmentId String
  action       String   // ASSIGNED, PICKED_UP, RETURNED, MARKED_OVERDUE, MARKED_LOST, etc.
  fromStatus   String?
  toStatus     String?
  notes        String?
  performedBy  String
  performedAt  DateTime @default(now())

  assignment   MusicAssignment @relation(fields: [assignmentId], references: [id], onDelete: Cascade)

  @@index([assignmentId])
  @@index([performedAt])
}

// ====================================
// Smart Upload Models
// ====================================

/**
 * SmartUploadBatch - Top-level batch owned by a user
 * Represents a single drag-and-drop upload session
 */
model SmartUploadBatch {
  id              String           @id @default(cuid())
  userId          String           // Owner of the batch
  status          SmartUploadStatus @default(CREATED)
  currentStep     SmartUploadStep?

  // Summary counts
  totalFiles      Int              @default(0)
  processedFiles  Int              @default(0)
  successFiles    Int              @default(0)
  failedFiles     Int              @default(0)

  // Timestamps
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  completedAt     DateTime?

  // Error summary
  errorSummary    String?

  // Relations
  items           SmartUploadItem[]
  proposals       SmartUploadProposal[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

/**
 * SmartUploadItem - Each uploaded file in a batch
 * Tracks per-step status, errors, and derived artifacts
 */
model SmartUploadItem {
  id              String           @id @default(cuid())
  batchId         String

  // File info
  fileName        String
  fileSize        Int
  mimeType        String
  storageKey      String?

  // Processing status
  status          SmartUploadStatus @default(CREATED)
  currentStep     SmartUploadStep?

  // Error tracking
  errorMessage    String?
  errorDetails    Json?

  // Extracted content
  ocrText         String?          @db.Text
  extractedMeta   Json?            // Raw LLM-extracted metadata

  // Split tracking (for packet PDFs)
  isPacket        Boolean          @default(false)
  splitPages      Int?             // Number of pages if split
  splitFiles      Json?            // Array of split file info

  // Timestamps
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  completedAt     DateTime?

  // Relations
  batch           SmartUploadBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)
  proposals       SmartUploadProposal[]

  @@index([batchId])
  @@index([status])
}

/**
 * SmartUploadProposal - Normalized extracted metadata + mapping
 * Represents the AI-generated proposal for review and approval
 */
model SmartUploadProposal {
  id              String           @id @default(cuid())
  itemId          String
  batchId         String

  // Proposed metadata
  title           String?
  composer        String?
  arranger        String?
  publisher       String?
  difficulty      String?
  genre           String?
  style           String?
  instrumentation String?
  duration        Int?
  notes           String?

  // Confidence scores (0-1)
  titleConfidence     Float?
  composerConfidence  Float?
  difficultyConfidence Float?

  // Approval status
  isApproved      Boolean          @default(false)
  approvedAt      DateTime?
  approvedBy      String?

  // User corrections (JSON blob of field -> corrected value)
  corrections     Json?

  // Mapping to existing piece (if matched)
  matchedPieceId  String?
  isNewPiece     Boolean          @default(true)

  // Timestamps
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relations
  item            SmartUploadItem  @relation(fields: [itemId], references: [id], onDelete: Cascade)
  batch           SmartUploadBatch @relation(fields: [batchId], references: [id], onDelete: Cascade)

  @@index([itemId])
  @@index([batchId])
  @@index([isApproved])
}

// ====================================
// Smart Upload Settings & AI Configuration
// ====================================

// Smart Upload Feature Settings (key-value approach for flexibility)
model SmartUploadSetting {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  description String?
  category    String   @default("general") // general, feature, limits
  isPublic    Boolean  @default(false) // whether visible to non-admins
  updatedAt   DateTime @updatedAt
  updatedBy   String?

  @@index([key])
  @@index([category])
}

// AI Provider Configuration
model AIProvider {
  id           String    @id @default(cuid())
  providerId   String    @unique // openai, anthropic, gemini, etc.
  displayName  String
  description  String?
  baseUrl      String?   // Custom endpoint URL
  logoUrl      String?
  isEnabled    Boolean   @default(false)
  isDefault    Boolean   @default(false)
  sortOrder    Int       @default(0)
  capabilities Json?     // { vision: true, structuredOutput: true }

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  apiKeys      APIKey[]
  models       AIModel[]
  primaryTaskConfigs  TaskModelConfig[]  @relation("TaskPrimaryProvider")
  fallbackTaskConfigs TaskModelConfig[]  @relation("TaskFallbackProvider")

  @@index([isEnabled])
  @@index([sortOrder])
}

// API Keys (encrypted at rest)
model APIKey {
  id              String    @id @default(cuid())
  providerId      String
  keyName         String?   // Optional name for identification
  encryptedKey    String    @db.Text // AES-256 encrypted API key (IV:authTag:cipherText hex format)
  keyHash         String    // SHA-256 hash for validation (never decrypted)
  isValid         Boolean   @default(false)
  validationError String?   // Last validation error
  lastValidated   DateTime?
  expiresAt       DateTime? // Optional expiration
  isActive        Boolean   @default(true)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  createdBy       String?

  // Relations
  provider        AIProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)

  @@index([providerId])
  @@index([isActive])
}

// Available Models per Provider
model AIModel {
  id                      String    @id @default(cuid())
  providerId              String
  modelId                 String    // Provider's model identifier (e.g., gpt-4o-mini)
  displayName             String
  description             String?

  // Capabilities
  supportsVision          Boolean   @default(false)
  supportsStructuredOutput Boolean  @default(false)
  supportsStreaming       Boolean   @default(false)
  maxTokens              Int?
  contextWindow           Int?

  // Cache management
  lastFetched             DateTime? // When model list was last fetched
  isAvailable            Boolean   @default(true)

  // Default selection
  isDefault              Boolean   @default(false)
  isPreferred            Boolean   @default(false) // User preference

  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  // Relations
  provider               AIProvider @relation(fields: [providerId], references: [id], onDelete: Cascade)
  parameters             ModelParameter[]
  taskConfigs            TaskModelConfig[]
  fallbackTaskConfigs    TaskModelConfig[]  @relation("TaskFallbackModel")

  @@unique([providerId, modelId])
  @@index([providerId])
  @@index([isDefault])
  @@index([isPreferred])
}

// Configurable Parameters per Model
model ModelParameter {
  id            String    @id @default(cuid())
  modelId       String

  // Parameter definition
  name          String    // temperature, max_tokens, top_p, etc.
  displayName   String
  description   String?
  paramType     String    // float, int, string, boolean

  // Constraints
  defaultValue  Float?    // For numeric types
  minValue      Float?
  maxValue      Float?
  stringDefault String?   // For string types
  allowedValues Json?     // For enum-like params

  // User override
  userValue     Float?
  userStringValue String?

  // Metadata
  isAdvanced    Boolean   @default(false)
  isVisible     Boolean   @default(true)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  model         AIModel   @relation(fields: [modelId], references: [id], onDelete: Cascade)

  @@unique([modelId, name])
  @@index([modelId])
}

// Settings Change Audit Log
model SettingsAuditLog {
  id            String    @id @default(cuid())

  // What changed
  entityType    String    // SmartUploadSetting, AIProvider, APIKey, AIModel, ModelParameter
  entityId      String
  action        String    // CREATE, UPDATE, DELETE, VALIDATE, ENABLE, DISABLE

  // Value changes
  fieldName     String?   // Which field changed (null for entity-level actions)
  oldValue      String?   // JSON serialized
  newValue      String?   // JSON serialized

  // Who made the change
  changedBy     String?   // User ID
  ipAddress     String?
  userAgent     String?

  timestamp     DateTime  @default(now())

  @@index([entityType, entityId])
  @@index([timestamp])
  @@index([changedBy])
}

// Task-specific Model Configuration for Upload Pipeline
model TaskModelConfig {
  id          String          @id @default(cuid())
  taskType    UploadTaskType  @unique // One config per task type

  // Model assignment (null = use global default)
  modelId     String?         // Reference to AIModel.id

  // Provider assignment for primary and fallback
  primaryProviderId  String?    // FK to AIProvider.id — which provider to use
  fallbackProviderId String?    // FK to AIProvider.id — fallback if primary fails
  fallbackModelId    String?    // FK to AIModel.id — fallback model if primary fails

  // Task-specific parameters
  temperature Float?          // 0-2 range
  maxTokens   Int?            // 1-128000 range
  topP        Float?          // 0-1 range

  // Timestamps
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  // Relation (optional - modelId can be null for default behavior)
  model       AIModel?        @relation(fields: [modelId], references: [id], onDelete: SetNull)
  primaryProvider AIProvider? @relation("TaskPrimaryProvider", fields: [primaryProviderId], references: [id], onDelete: SetNull)
  fallbackProvider AIProvider? @relation("TaskFallbackProvider", fields: [fallbackProviderId], references: [id], onDelete: SetNull)
  fallbackModel AIModel?      @relation("TaskFallbackModel", fields: [fallbackModelId], references: [id], onDelete: SetNull)

  @@index([taskType])
  @@index([modelId])
  @@index([primaryProviderId])
  @@index([fallbackProviderId])
  @@index([fallbackModelId])
}

/*
 * deprecates:
 *
 * model MicrosoftGraphClientUser {
 *   id            String    @id @unique
 *   email         String
 *   accessToken   String?
 *   refreshToken  String?
 *   scope         String?
 *   expiresAt   DateTime?
 * }
 *
 * model FreshBooksProviderUser {
 *   id            String    @id @unique
 *   accessToken   String?
 *   refreshToken  String?
 *   scope         String?
 *   expiresAt   DateTime?
 * }
 */

enum AssignmentStatus {
  ASSIGNED      // Music assigned to member, waiting for pickup
  PICKED_UP     // Member has picked up the music
  RETURNED      // Member has returned the music
  OVERDUE       // Return is past due date
  LOST          // Music reported as lost
  DAMAGED       // Music returned in damaged condition
}

model FileDownload {
  id          String     @id @default(cuid())
  fileId      String
  userId      String?
  downloadedAt DateTime  @default(now())
  ipAddress    String?
  userAgent    String?
  bytesTransferred Int?
  
  file        MusicFile  @relation(fields: [fileId], references: [id], onDelete: Cascade)
  
  @@index([fileId])
  @@index([userId])
  @@index([downloadedAt])
}

// ====================================
// Events & Rehearsals
// ====================================

enum EventType {
  CONCERT
  REHEARSAL
  SECTIONAL
  BOARD_MEETING
  SOCIAL
  OTHER
}

enum AttendanceStatus {
  PRESENT
  ABSENT
  EXCUSED
  LATE
  LEFT_EARLY
}

model Event {
  gigChecklist Json?
  carpoolEntries CarpoolEntry[]

  id              String       @id @default(cuid())
  title           String
  description     String?
  type            EventType
  startTime       DateTime
  endTime         DateTime
  location        String?
  venueId         String?
  callTime        DateTime?
  dressCode       String?
  programOrder    Json?
  isCancelled     Boolean      @default(false)
  isPublished     Boolean      @default(false)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  deletedAt       DateTime?
  
  venue           Venue?       @relation(fields: [venueId], references: [id])
  attendance      Attendance[]
  music           EventMusic[]
  notes           EventNote[]
  
  @@index([type])
  @@index([startTime])
  @@index([isPublished])
  @@index([deletedAt])
}

model Venue {
  id          String   @id @default(cuid())
  name        String
  address     String?
  city        String?
  state       String?
  zipCode     String?
  directions  String?
  parking     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  events      Event[]
  
  @@index([name])
}

model Attendance {
  id          String           @id @default(cuid())
  eventId     String
  memberId    String
  status      AttendanceStatus
  notes       String?
  markedAt    DateTime         @default(now())
  markedBy    String?
  
  event       Event            @relation(fields: [eventId], references: [id], onDelete: Cascade)
  member      Member           @relation(fields: [memberId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, memberId])
  @@index([eventId])
  @@index([memberId])
  @@index([status])
}

model EventMusic {
  id          String     @id @default(cuid())
  eventId     String
  pieceId     String
  sortOrder   Int        @default(0)
  notes       String?
  
  event       Event      @relation(fields: [eventId], references: [id], onDelete: Cascade)
  piece       MusicPiece @relation(fields: [pieceId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, pieceId])
  @@index([eventId])
  @@index([pieceId])
}

model EventNote {
  id          String   @id @default(cuid())
  eventId     String
  title       String?
  content     String
  isPublic    Boolean  @default(false)
  targetSection String?
  createdAt   DateTime @default(now())
  createdBy   String?
  updatedAt   DateTime @updatedAt
  
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  @@index([eventId])
}

// ====================================
// CMS & Content
// ====================================

enum ContentStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  ARCHIVED
}

model Page {
  id          String        @id @default(cuid())
  title       String
  slug        String        @unique
  description String?
  content     Json
  rawMarkdown String?
  metaTitle   String?
  metaDescription String?
  metaKeywords Json?
  ogImage     String?
  status      ContentStatus @default(DRAFT)
  publishedAt DateTime?
  scheduledFor DateTime?
  version     Int           @default(1)
  parentVersionId String?
  createdAt   DateTime      @default(now())
  createdBy   String?
  updatedAt   DateTime      @updatedAt
  updatedBy   String?
  deletedAt   DateTime?
  
  versions    PageVersion[]
  
  @@index([slug])
  @@index([status])
  @@index([publishedAt])
}

model PageVersion {
  id          String   @id @default(cuid())
  pageId      String
  version     Int
  content     Json
  createdAt   DateTime @default(now())
  createdBy   String?
  
  page        Page     @relation(fields: [pageId], references: [id], onDelete: Cascade)
  
  @@unique([pageId, version])
  @@index([pageId])
}

model Announcement {
  id          String             @id @default(cuid())
  title       String
  content     String
  type        AnnouncementType   @default(INFO)
  audience    AnnouncementAudience @default(ALL)
  targetRoles Json?
  isUrgent    Boolean            @default(false)
  isPinned    Boolean            @default(false)
  status      ContentStatus      @default(DRAFT)
  publishAt   DateTime?
  publishedAt DateTime?
  expiresAt   DateTime?
  createdAt   DateTime           @default(now())
  createdBy   String?
  updatedAt   DateTime           @updatedAt
  
  author        User?              @relation(fields: [createdBy], references: [id])
  notifications UserNotification[]
  
  @@index([status])
  @@index([publishAt])
  @@index([publishedAt])
  @@index([expiresAt])
  @@index([isPinned])
}

enum AnnouncementType {
  INFO
  WARNING
  URGENT
  EVENT
}

enum AnnouncementAudience {
  ALL
  MEMBERS
  ADMINS
}

model MediaAsset {
  id          String   @id @default(cuid())
  fileName    String
  fileSize    Int
  mimeType    String
  storageKey  String
  storageUrl  String?
  title       String?
  altText     String?
  caption     String?
  tags        Json?
  width       Int?
  height      Int?
  uploadedAt  DateTime @default(now())
  uploadedBy  String?
  
  @@index([mimeType])
  @@index([uploadedAt])
}

// ====================================
// Communications
// ====================================

enum EmailTemplateType {
  WELCOME
  PASSWORD_RESET
  EVENT_REMINDER
  ANNOUNCEMENT
  ATTENDANCE_SUMMARY
  CUSTOM
}

model EmailTemplate {
  id          String           @id @default(cuid())
  name        String           @unique
  type        EmailTemplateType @default(CUSTOM)
  subject     String
  body        String           // HTML body with {{variable}} placeholders
  textBody    String?          // Plain text version
  description String?          // Description of when to use this template
  variables   Json?            // Array of variable names this template uses
  isActive    Boolean          @default(true)
  isDefault   Boolean          @default(false)  // Default template for this type
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  createdBy   String?
  
  @@index([type])
  @@index([isActive])
}

enum NotificationType {
  ANNOUNCEMENT
  EVENT_REMINDER
  MUSIC_ASSIGNMENT
  ATTENDANCE_REMINDER
  SYSTEM
}

model UserNotification {
  id             String           @id @default(cuid())
  userId         String
  type           NotificationType
  title          String
  message        String
  linkUrl        String?
  linkText       String?
  announcementId String?
  eventId        String?
  isRead         Boolean          @default(false)
  readAt         DateTime?
  createdAt      DateTime         @default(now())
  
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  announcement   Announcement?    @relation(fields: [announcementId], references: [id])

  updatedBy String?
  updatedAt DateTime?      @updatedAt

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
}

model Message {
  id          String   @id @default(cuid())
  subject     String
  body        String
  senderId    String
  senderName  String
  recipients  Json
  sentAt      DateTime @default(now())
  
  @@index([senderId])
  @@index([sentAt])
}

// ====================================
// Configuration & System
// ====================================

enum EmailStatus {
  PENDING
  SENT
  FAILED
  BOUNCED
}

model EmailLog {
  id             String      @id @default(cuid())
  subject        String
  body           String
  recipientCount Int
  recipientType  String
  status         EmailStatus @default(PENDING)
  sentById       String?
  sentAt         DateTime?
  errorMessage   String?
  createdAt      DateTime    @default(now())

  updatedBy String?
  updatedAt DateTime? @updatedAt

  sentBy         User?       @relation(fields: [sentById], references: [id])
  
  @@index([sentById])
  @@index([status])
  @@index([createdAt])
}

model SystemSetting {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  description String?
  updatedAt   DateTime @updatedAt
  updatedBy   String?
  
  @@index([key])
}

model AuditLog {
  id          String   @id @default(cuid())
  userId      String?
  userName    String?
  ipAddress   String?
  userAgent   String?
  action      String
  entityType  String
  entityId    String?
  oldValues   Json?
  newValues   Json?
  timestamp   DateTime @default(now())
  
  user        User?    @relation(fields: [userId], references: [id])
  
  @@index([userId])
  @@index([entityType, entityId])
  @@index([timestamp])
  @@index([action])
}


model SectionMessage {
  id        String   @id @default(cuid())
  sectionId String
  memberId  String
  content   String
  createdAt DateTime @default(now())

  section   Section  @relation(fields: [sectionId], references: [id], onDelete: Cascade)
  member    Member   @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@index([sectionId])
}

enum CarpoolType {
  OFFER
  REQUEST
}

model CarpoolEntry {
  id        String      @id @default(cuid())
  eventId   String
  memberId  String
  type      CarpoolType
  seats     Int?
  location  String?
  notes     String?
  createdAt DateTime    @default(now())

  event     Event       @relation(fields: [eventId], references: [id], onDelete: Cascade)
  member    Member      @relation(fields: [memberId], references: [id], onDelete: Cascade)

  @@index([eventId])
}
